#!/bin/sh -eu

# build-images: build container images
# Copyright (C) 2020  "Michael G. Morey" <mgmorey@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

TAG="$(date +%Y%m%d%H%M)"

abort() {
    printf "$@" >&2
    exit 1
}

assert() {
    "$@" || abort "%s: Assertion failed: %s\n" "$0" "$*"
}

build_images() {
    for dockerfile; do
	dir=$(get_realpath "$(dirname "$dockerfile")")
	image=$(printf "%s\n" "$dir" | get_image_name)
	build_image $dir $image
    done
}

build_image() (
    dir=$1
    image=$2

    if [ -z "$method" ]; then
	method=$(get_default_method $image)
    fi

    repo_image=${IMAGE_BASE_URL+$IMAGE_BASE_URL/}${image#*/}:${tag:-$TAG}

    if [ -d "$dir" ]; then
	cd "$dir"

	if [ "$with_build" = true ]; then
	    create_builder $method
	    $(get_command $method) $(get_build_subcommand $method $image)
	fi

	if [ "$with_push" = true -a "$repo_image" != "$image" ]; then
	    $(get_command $method) tag $image $repo_image
	    $(get_command $method) push $repo_image
	fi
    fi
)

create_builder() {
    assert [ $# -eq 1 ]
    assert [ -n "$1" ]

    case $1 in
	(buildx)
	    builder=$(get_insecure_builder)

	    if [ "$builder" != insecure-builder ]; then
		docker buildx create \
		       --use \
		       --name insecure-builder \
		       --buildkitd-flags \
		       '--allow-insecure-entitlement security.insecure'
	    fi
	    ;;
    esac
}

get_build_subcommand() {
    assert [ $# -eq 2 ]
    assert [ -n "$1" ]
    assert [ -n "$2" ]

    case "$1" in
	(buildah)
	    printf "%s\n" bud --cap-add=all -t "$2" .
	    ;;
	(buildx)
	    printf "%s\n" buildx build \
		   --allow security.insecure \
		   --load -t "$2" .
	    ;;
	(docker)
	    printf "%s\n" build -t "$2" .
	    ;;
	(podman)
	    printf "%s\n" build -t "$2" .
	    ;;
    esac
}

get_command() {
    assert [ $# -eq 1 ]
    assert [ -n "$1" ]

    case "$1" in
	(buildah)
	    printf "%s\n" buildah
	    ;;
	(buildx)
	    printf "%s\n" docker
	    ;;
	(docker)
	    printf "%s\n" docker
	    ;;
	(podman)
	    printf "%s\n" podman
	    ;;
    esac
}

get_default_method() {
    assert [ $# -eq 1 ]
    assert [ -n "$1" ]

    case "$1" in
	(*-ibm-db2-*)
	    printf "%s\n" buildah
	    ;;
	(*)
	    printf "%s\n" docker
	    ;;
    esac
}

get_dockerfiles() {
    dir_prefix=$(get_image_dir_prefix)
    dir_root=$(get_image_dir_root)
    find "$dir_root" -type f -name Dockerfile
}

get_image_dir_prefix() {
    printf "%s\n" "${IMAGE_DIR_PREFIX-docker}-"
}

get_image_dir_root() {
    printf "%s\n" "$(get_realpath "${IMAGE_DIR_ROOT-$HOME}")"
}

get_image_name() {
    dir_prefix=$(get_image_dir_prefix)
    name_prefix=${IMAGE_NAME_PREFIX+$IMAGE_NAME_PREFIX-}
    sed -e 's|^.*/'"$dir_prefix"'\(.*\)/|'"${name_prefix}"'\1-|' \
	-e 's/\.0$//'
}

get_insecure_builder() {
    docker buildx ls | awk 'NR > 1 && $1 == "insecure-builder" { print $1 }'
}

get_realpath() (
    assert [ $# -ge 1 ]
    realpath=$(which realpath)

    if [ -n "$realpath" ]; then
	$realpath "$@"
    else
	for file; do
	    if expr "$file" : '/.*' >/dev/null; then
		printf "%s\n" "$file"
	    else
		printf "%s\n" "$PWD/${file#./}"
	    fi
	done
    fi
)

parse_arguments() {
    dockerfiles=
    method=
    tag=
    with_build=false
    with_push=false

    while getopts M:blpt:h opt; do
	case $opt in
	    (M)
		case "$OPTARG" in
		    (buildah)
			method="$OPTARG"
			;;
		    (buildx)
			if [ "${DOCKER_CLI_EXPERIMENTAL-}" = enabled ]; then
			    method="$OPTARG"
			fi
			;;
		    (docker)
			method="$OPTARG"
			;;
		    (podman)
			method="$OPTARG"
			;;
		    (*)
			usage_error "%s: %s: Invalid method\n" "$0" "$OPTARG"
			;;
		esac
		;;
	    (b)
		with_build=true
		;;
	    (l)
		tag=latest
		with_push=true
		;;
	    (p)
		with_push=true
		with_push=true
		;;
	    (t)
		tag="$OPTARG"
		with_push=true
		;;
	    (h)
		usage
		exit 0
		;;
	    (\?)
		usage_error
		;;
	esac
    done

    if [ "$with_build" = false -a "$with_push" = false ]; then
	with_build=true
	with_push=true
    fi

    shift $(($OPTIND - 1))

    for file; do
	if [ -f "$file" ]; then
	    case "$file" in
		(*/Dockerfile|Dockerfile)
		    dockerfiles="${dockerfiles+$dockerfiles }$file"
		    ;;
		(*)
		    abort "%s: %s: Not a Dockerfile\n" "$0" "$file"
		    ;;
	    esac
	elif [ -e "$file" ]; then
	    abort "%s: %s: Not a Dockerfile\n" "$0" "$file"
	else
	    abort "%s: %s: No such file\n" "$0" "$file"
	fi
    done
}

usage() {
    cat <<EOF >&2
Usage: $0 [-M METHOD] [-b] [-l] [-p] [-t TAG]
       $0 -h
EOF
}

usage_error() {
    if [ $# -gt 0 ]; then
	printf "$@" >&2
    fi

    printf "%s\n" '' >&2
    usage
    exit 2
}

case "$0" in
    (*/*)
	script_dir=$(get_realpath "$(dirname "$0")")
	;;
    (*)
	script_dir=
	;;
esac

script_prefix=${script_dir:+$script_dir/}

parse_arguments "$@"
build_images ${dockerfiles:-$(get_dockerfiles)}
