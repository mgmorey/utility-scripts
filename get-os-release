#!/bin/sh -eu

# get-os-release: print OS distro/release information
# Copyright (C) 2018  "Michael G. Morey" <mgmorey@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

FILE_DEBIAN_VERSION=/etc/debian_version
FILE_OS_RELEASE=/etc/os-release
FILE_REDHAT_RELEASE=/etc/redhat-release
FILE_RELEASE=/etc/release

VARS_STANDARD="ID NAME PRETTY_NAME VERSION VERSION_ID family kernel_name"
VARS_EXTENDED="kernel_release os_id_like os_version os_version_id \
debian_codename redhat_release redhat_version_id"

abort() {
    printf "$@" >&2
    exit 1
}

assert() {
    "$@" || abort "%s: Assertion failed: %s\n" "$0" "$*"
}

abort_conflicting_option() {
    usage "%s: conflicting option -- %s\n" "$0" "$1"
    exit 2
}

abort_too_many_arguments() {
    usage "%s: too many arguments -- %s\n" "$0" "$*"
    exit 2
}

collect_data() {
    kernel_data=$(uname -sr)
    kernel_name=${kernel_data% *}
    kernel_release=${kernel_data#* }

    case "$kernel_name" in
	(CYGWIN_NT-*)
	    collect_data_for_cygwin
	    ;;
	(Linux|GNU)
	    collect_data_for_gnu
	    ;;
	(Darwin)
	    collect_data_for_darwin
	    ;;
	(SunOS)
	    collect_data_for_sunos
	    ;;
	(*)
	    collect_data_for_unix
	    ;;

    esac

    collect_defaults
}

collect_data_for_cygwin() {
    kernel_release=$(printf "%s\n" "${kernel_data#* }" | sed -e 's/(.*)//')
    NAME="Microsoft Windows"
    VERSION=${kernel_name#*-}
    ID=ms-windows
    family=cygwin
}

collect_data_for_darwin() {
    NAME=$(sw_vers -productName)
    VERSION=$(sw_vers -productVersion)
    ID=macos
    family=darwin
}

collect_data_for_gnu() {
    . $FILE_OS_RELEASE

    case "$kernel_name" in
	(GNU)
	    family=gnu-hurd
	    ;;
	(Linux)
	    family=gnu-linux
	    ;;
    esac

    if [ "$is_extended_set" = false ]; then
	return
    fi

    os_version_id=$(get_os_version_id)

    case "$ID" in
	(debian|raspbian|ubuntu|linuxmint|neon|kali)
	    debian_codename=$(cat /etc/debian_version)
	    ;;
	(fedora|rhel|ol|centos)
	    redhat_release=$(cat /etc/redhat-release)
	    redhat_version_id=$os_version_id
	    ;;
    esac
}

collect_data_for_sunos() {
    os_data=$(awk 'NR == 1 {printf("%s %s:%s\n", $1, $2, $3)}' $FILE_RELEASE)
    NAME=${os_data%:*}
    VERSION=${os_data#*:}
    ID=$(printf "%s\n" "${NAME% *}" | to_lower)
    family=sunos
}

collect_data_for_unix() {
    NAME=$kernel_name
    VERSION=$kernel_release
    ID=$(printf "%s\n" "$NAME" | to_lower)
    PRETTY_NAME=$kernel_data

    case "$kernel_name" in
	(*BSD)
	    family=bsd
	    ;;
	(*)
	    family=unix
	    ;;
    esac
}

collect_defaults() {
    if [ -z "${VERSION-}" ]; then
	VERSION=
    fi

    if [ -z "${VERSION_ID-}" ]; then
	VERSION_ID="$VERSION"
    fi

    if [ -z "${PRETTY_NAME-}" ]; then
	PRETTY_NAME="$NAME $VERSION"
    fi

    if [ "$is_extended_set" = false ]; then
	return
    fi

    if [ -z "${os_id_like-}" ]; then
	os_id_like="${ID_LIKE:-ID}"
    fi

    if [ -z "${os_version_id-}" ]; then
	os_version_id=$VERSION_ID
    fi

    if [ -z "${os_version-}" ]; then
	os_version=$VERSION
    fi
}

get_os_version_id() {
    case "$kernel_name" in
	(Linux|GNU)
	    case "$ID" in
		(debian|raspbian)
		    cat /etc/debian_version
		    ;;
		(ubuntu)
		    printf "%s\n" "$VERSION" | awk '{print $1}'
		    ;;
		(fedora|rhel|ol|centos)
		    "$script_dir/get-redhat-version" /etc/redhat-release
		    ;;
	    esac
	    ;;
    esac
}

get_realpath() (
    assert [ $# -ge 1 ]
    realpath=$(which realpath)

    if [ -n "$realpath" ]; then
	$realpath "$@"
    else
	for file; do
	    if expr "$file" : '/.*' >/dev/null; then
		printf "%s\n" "$file"
	    else
		printf "%s\n" "$PWD/${file#./}"
	    fi
	done
    fi
)

output_data() {
    if [ -z "${vars-}" ]; then
	vars=PRETTY_NAME
    fi

    if [ "$is_shell_format" = true ]; then
	for var in $vars; do
	    eval val="\${$var-}"
	    printf "%s=\"%s\"\n" "$var" "$val"
	done
    else
	for var in $vars; do
	    eval val="\${$var-}"
	    printf "%s\n" "$val"
	done
    fi
}

parse_arguments() {
    is_extended_set=false
    is_shell_format=false
    vars=

    while getopts Xhiknprvx opt; do
	case $opt in
	    (i)
		queue_vars ID
		;;
	    (k)
		queue_vars kernel_name
		;;
	    (n)
		queue_vars NAME
		;;
	    (p)
		queue_vars PRETTY_NAME
		;;
	    (r)
		queue_vars kernel_release
		;;
	    (v)
		queue_vars VERSION_ID
		;;
	    (x)
		queue_vars $VARS_STANDARD
		;;
	    (X)
		is_extended_set=true
		queue_vars $VARS_STANDARD $VARS_EXTENDED
		;;
	    (h)
		usage
		exit 0
		;;
	    (\?)
		printf "%s\n" "" >&2
		usage
		exit 2
		;;
	esac
    done

    shift $(($OPTIND - 1))

    if [ $# -gt 0 ]; then
	abort_too_many_arguments "$@"
    fi
}

queue_vars() {
    if [ $# -gt 1 ]; then
	if [ $is_shell_format = false -a -z "$vars" ]; then
	    is_shell_format=true
	    vars="$*"
	else
	    abort_conflicting_option $opt
	fi
    elif [ $# -eq 1 ]; then
	if [ $is_shell_format = false ]; then
	    vars="${vars}${vars:+ }$1"
	else
	    abort_conflicting_option $opt
	fi
    fi
}

to_lower() {
    tr '[:upper:]' '[:lower:]'
}

usage() {
    if [ $# -gt 0 ]; then
	printf "$@" >&2
	printf "%s\n" "" >&2
    fi

    cat <<-EOF >&2
	Usage: $0: [-i] [-k] [-n] [-p] [-r] [-v]
	       $0: -x
	       $0: -X
	       $0: -h
	EOF
}

script_dir=$(get_realpath "$(dirname "$0")")

parse_arguments "$@"
collect_data
output_data
