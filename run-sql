#!/bin/sh -eu

# run-sql: invoke SQL DBMS command line client
# Copyright (C) 2018  "Michael G. Morey" <mgmorey@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

SQL_DIRS="scripts sql"

abort() {
    printf "$@" >&2
    exit 1
}

assert() {
    "$@" || abort "%s: Assertion failed: %s\n" "$0" "$*"
}

configure_platform() {
    user=$(get_user_name)
}

exec_sql_command() {
    eval ${1+$1 }$(get_cli_command)
}

format_pathname() {
    printf "$1/$2\n"
}

get_cli_command() {
    case "$DATABASE_DIALECT" in
	(mssql)
	    get_cli_mssql
	    ;;
	(mysql)
	    get_cli_mysql
	    ;;
	(oracle)
	    get_cli_oracle
	    ;;
	(postgresql)
	    get_cli_postgresql
	    ;;
	(sqlite)
	    get_cli_sqlite
	    ;;
	(*)
	    abort "%s: Invalid SQL dialect '%s'\n" "$DATABASE_DIALECT"
    esac
}

get_cli_mssql() {
    printf "%s\n" sqlcmd \
	   -H ${DATABASE_HOST:-${MSSQL_HOST:-localhost}} \
	   -U ${DATABASE_USER:-${MSSQL_USER:-$user}} \
	   -P ${DATABASE_PASSWORD:-${MYSQL_PASSWORD-}} \
	   # -d ${DATABASE_INSTANCE:-${MYSQL_INSTANCE-}}
}

get_cli_mysql() {
    printf "%s\n" mysql \
	   --protocol=${DATABASE_PROTOCOL:-${MYSQL_PROTOCOL:-TCP}} \
	   --host=${DATABASE_HOST:-${MYSQL_HOST:-localhost}} \
	   --port=${DATABASE_PORT:-${MYSQL_PORT:-3306}} \
	   --user=${DATABASE_USER:-${MYSQL_USER:-$user}} \
	   --password=${DATABASE_PASSWORD:-${MYSQL_PASSWORD-}} \
	   --database=${DATABASE_INSTANCE:-${MYSQL_INSTANCE:-mysql}}

    if [ -n "${command-}" ]; then
	printf "%s\n" --execute="\"$command\""
    fi
}

get_cli_oracle() {
    host=${DATABASE_HOST:-${ORACLE_HOST:-localhost}}
    port=${DATABASE_PORT:-${ORACLE_PORT:-1521}}
    username=${DATABASE_USER:-${ORACLE_USER:-$user}}
    password=${DATABASE_PASSWORD:-${ORACLE_PASSWORD-}}
    instance=${DATABASE_INSTANCE:-${ORACLE_INSTANCE:-ORCLCDB}}
    printf "%s\n" sqlplus "$username/$password@//$host:$port/$instance"
}

get_cli_postgresql() {
    printf "%s\n" psql \
	   --host=${DATABASE_HOST:-${POSTGRES_HOST:-localhost}} \
	   --port=${DATABASE_PORT:-${POSTGRES_PORT:-5432}} \
	   --username=${DATABASE_USER:-${POSTGRES_USER:-$user}} \
	   --password

    if [ -n "${command-}" ]; then
	printf "%s\n" --command="\"$command\""
    fi
}

get_cli_sqlite() {
    printf "%s\n" sqlite3 ${DATABASE_PATHNAME:-${SQLITE_PATHNAME-}}
}

get_realpath() (
    assert [ $# -ge 1 ]
    realpath=$(which realpath)

    if [ -n "$realpath" ]; then
	$realpath "$@"
    else
	for file; do
	    if expr "$file" : '/.*' >/dev/null; then
		printf "%s\n" "$file"
	    else
		printf "%s\n" "$PWD/${file#./}"
	    fi
	done
    fi
)

get_user_name() {
    printf "%s\n" "${SUDO_USER-${USER-${USERNAME-${LOGNAME-}}}}"
}

parse_argument() {
    script=

    case "$1" in
	(*.sql)
	    name=$1
	    ;;
	(*.sqlite)
	    if [ "$DATABASE_DIALECT" = sqlite ]; then
		DATABASE_PATHNAME=$1
	    else
		abort "%s: Invalid SQL script name: %s\n" "$0" "$1"
	    fi
	    ;;
	(*)
	    name="$1.sql"
	    ;;
    esac

    if [ -z "${name:-}" ]; then
	return 1
    elif [ -e "$name" ]; then
	script="$1"
    else
	for sql_dir in $SQL_DIRS; do
	    file="$(format_pathname $sql_dir $name)"

	    if [ -e "$file" ]; then
		script="$file"
		break
	    fi
	done

	if [ -z "${script}" ]; then
	    abort "%s: No such script file\n" "$name"
	fi
    fi

    scripts="${scripts:+$scripts }$script"
}

parse_arguments() {
    command=
    scripts=

    while getopts hc: opt; do
	case $opt in
	    (c)
		command=$OPTARG
		;;
	    (h)
		usage
		exit 0
		;;
	    (\?)
		printf "%s\n" "" >&2
		usage
		exit 2
		;;
	esac
    done

    shift $(($OPTIND - 1))

    if [ $# -gt 0 ]; then
	for arg; do
	    parse_argument $arg
	done
    fi
}

run_sql() {
    configure_platform

    if [ -n "$scripts" ]; then
	for script in $scripts; do
	    if [ -f $script ]; then
		exec <$script
		exec_sql_command
	    elif [ -d $script ]; then
		abort "%s: %s: Is a directory\n" "$0" "$script"
	    else
		abort "%s: %s: No such script file\n" "$0" "$script"
	    fi
	done
    else
	exec_sql_command exec
    fi
}

usage() {
    if [ $# -gt 0 ]; then
	printf "$@" >&2
	printf "%s\n" "" >&2
    fi

    cat <<-EOF >&2
	Usage: $0: [-c COMMAND]
	       $0: [SCRIPT ...]
	       $0: -h
	EOF
}

env_dir=$(pwd)

until [ "$env_dir" = / -o -r "$env_dir/.env" ]; do
    env_dir="$(dirname $env_dir)"
done

if [ -r "$env_dir/.env" ]; then
    env_file="$env_dir/.env"
elif [ -r "$HOME/.env" ]; then
    env_file="$HOME/.env"
else
    env_file=
fi

if [ -n "$env_file" ]; then
    if [ "${VENV_VERBOSE-false}" = true ]; then
	printf "%s\n" "Loading .env environment variables" >&2
    fi

    . "$env_file"
fi

if [ -z "${DATABASE_DIALECT-}" ]; then
    DATABASE_DIALECT=sqlite
fi

parse_arguments "$@"
run_sql
