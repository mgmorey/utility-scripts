#!/bin/sh -eu

# generate-docker-compose: print configuration file docker-compose.yaml
# Copyright (C) 2021  "Michael G. Morey" <mgmorey@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

AWK_FORMAT='s/^%s \\([1-9][0-9]*\\(\\.[0-9][0-9]*\\)*\\)*.*$/\\1/'
AWK_STRING='GNU Awk'
AWK_VERSION=4.0.0
FILE_VERSION=3.3
NAMED_VOLUMES=true

ENV_FILE=docker-environment.txt
PORT_FILE=docker-ports.txt
SERVICE_FILE=docker-service.txt
VOLUME_FILE=docker-volumes.txt

ENV_NAME_RE="[A-Za-z][0-9A-Z_a-z]+"
ENV_RE="${ENV_NAME_RE}=.+"
IPV4_RE="([0-9]{1,3}\\.){3}[0-9]{1,3}"
PORT_NUMBER_RE="[0-9]{1,5}"
PORT_RANGE_RE="${PORT_NUMBER_RE}(|-${PORT_NUMBER_RE})"
PORT_RE="(${IPV4_RE}:|)(${PORT_RANGE_RE}:|)${PORT_RANGE_RE}(|[/](tcp|udp))"
SERVICE_NAME_RE="[a-z][0-9_a-z]*"
SERVICE_RE="${SERVICE_NAME_RE}=.+"
VOLUME_NAME_RE='[a-z][0-9_a-z-]*'
VOLUME_PATH_RE="([/]${VOLUME_NAME_RE})+"
VOLUME_RE="\\.?(${VOLUME_PATH_RE})?:${VOLUME_PATH_RE}(|:${VOLUME_NAME_RE})"

abort() {
    printf "$@" >&2
    exit 1
}

assert() {
    "$@" || abort "%s: Assertion failed: %s\n" "$0" "$*"
}

check_device() {
    assert [ $# -eq 1 ]
    assert [ -n "$1" ]

    if [ ! -d "$1" ]; then
	printf '%s: WARNING: %s: No such directory\n' "$script" "$1" >&2
    fi
}

compare_versions() (
    assert [ $# -eq 3 ]
    assert [ -n "$3" ]

    if [ -z "$1" -a -z "$2" -o "$3" -le 0 ]; then
	printf '%s\n' 0
    else
	m=$(printf '%s\n' "${1:-0}" | cut -d. -f1)
	n=$(printf '%s\n' "${2:-0}" | cut -d. -f1)
	delta=$((m - n))

	if [ "$delta" -ne 0 ]; then
	    printf '%s\n' $delta
	else
	    printf '%s\n' "$(compare_versions ${1#*.} ${2#*.} $(($3 - 1)))"
	fi
    fi
)

find_file() {
    assert [ $# -eq 1 ]
    assert [ -n "$1" ]

    for dir in . .. "$HOME"; do
	file="$dir/$1"

	if [ -f "$file" ]; then
	    printf '%s\n' "$file"
	    return 0
	fi
    done

    printf '%s\n' "$1"
}

generate_docker_compose() {
    validate_platform
    env_file=$(find_file $ENV_FILE)
    port_file=$(find_file $PORT_FILE)
    service_file=$(find_file $SERVICE_FILE)
    volume_file=$(find_file $VOLUME_FILE)
    print_file_version
    print_services
    print_volumes
}

get_awk_version_number() {
    assert [ $# -eq 1 ]

    if [ -n "$1" ] && is_valid_awk_string "$1"; then
	printf '%s\n' "$1" | sed "$(printf "$AWK_FORMAT\n" "$AWK_STRING")"
    fi
}

get_awk_version_string() {
    awk --version 2>/dev/null | head -n 1
}

get_default_service_name() {
    image=$(get_service_param_value image | sed 's/:.*$//')

    if [ -n "$image" ]; then
	printf '%s\n' "$(basename $image)"
    else
	printf '%s\n' app
    fi
}

get_default_volume_name() {
    assert [ $# -eq 1 ]
    assert [ -n "$1" ]
    printf '%s\n' "$1" | awk -F/ '{printf("%s-%s\n", $(NF - 1), $NF)}'
}

get_environment_var_count() {
    get_environment_vars | wc -l
}

get_environment_vars() {
    if [ -f $env_file ]; then
	awk -F= '/^'"$ENV_RE"'$/ {print $1, $2}' $env_file
    fi
}

get_port_count() {
    get_ports | wc -l
}

get_ports() {
    if [ -f $port_file ]; then
	awk '/^'"$PORT_RE"'$/ {print $0}' $port_file
    fi
}

get_service_param_value() {
    assert [ $# -eq 1 ]
    assert [ -n "$1" ]
    awk -F= '$1 == "'"$1"'" {print $2}' $service_file
}

get_service_params() {
    awk -F= '/^'"$SERVICE_RE"'$/ {print $1, $2}' $service_file
}

get_volume_count() {
    get_volumes | wc -l
}

get_volumes() {
    if [ -f $volume_file ]; then
	awk -F: '/^'"$VOLUME_RE"'$/ {print $1, $2, $3}' $volume_file
    fi
}

is_valid_awk_string() {
    expr "${1-}" : "$AWK_STRING"' [1-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*' >/dev/null
}

parse_arguments() {
    named_volumes=$NAMED_VOLUMES

    while getopts nuh opt; do
	case $opt in
	    (n)
		named_volumes=true
		;;
	    (u)
		named_volumes=false
		;;
	    (h)
		usage
		exit 0
		;;
	    (\?)
		exit 2
		;;
	esac
    done

    shift $(($OPTIND - 1))

    if [ $# -gt 0 ]; then
	usage_error "%s: Too many arguments\n" "$script"
    fi
}

print_file_version() {
    printf '%s: "%s"\n' "version" "$FILE_VERSION"
}

print_service_environment() {
    if [ "$(get_environment_var_count)" -eq 0 ]; then
	return 0
    fi

    printf '        %s:\n' "environment"

    get_environment_vars | sort | while read var value; do
	printf '            - %s=%s\n' "$var" "$value"
    done
}

print_service_ports() {
    if [ "$(get_port_count)" -eq 0 ]; then
	return 0
    fi

    printf '        %s:\n' "ports"

    get_ports | while read port; do
	if expr "$port" : '^[0-9-]*$' >/dev/null; then
	    printf '            - %s:%s\n' "$port" "$port"
	else
	    printf '            - %s\n' "$port"
	fi
    done
}

print_service_volumes() {
    if [ "$(get_volume_count)" -eq 0 ]; then
	return 0
    fi

    printf '        %s:\n' "volumes"

    get_volumes | while read device mount name; do
	check_device "$device"

	if [ "$named_volumes" = true ]; then
	    print_volume_name_and_mount "$name" "$mount"
	else
	    print_volume_device_and_mount "$device" "$mount"
	fi
    done
}

print_services() {
    printf '%s\n' ''
    printf '%s:\n' "services"
    printf '%s\n' ''
    service_name=$(get_service_param_value service_name)
    printf '    %s:\n' "${service_name:-$(get_default_service_name)}"

    get_service_params | sort | while read param value; do
	if [ "$param" != service_name ]; then
	    printf '        %s: %s\n' "$param" "$value"
	fi
    done

    print_service_environment
    print_service_ports
    print_service_volumes
}

print_volume() {
    printf '%s\n' ''
    printf '    %s:\n' "${3:-$(get_default_volume_name $2)}"
    printf '        %s: %s\n' "driver" "local"
    printf '        %s:\n' "driver_opts"
    printf '            %s: %s\n' "o" "bind"
    printf '            %s: %s\n' "type" "none"
    printf '            %s: %s\n' "device" "$1"
}

print_volume_device_and_mount() {
    assert [ $# -eq 2 ]
    assert [ -n "$1" ]
    assert [ -n "$2" ]
    printf '            - %s:%s\n' "$1" "$2"
}

print_volume_name_and_mount() {
    assert [ $# -eq 2 ]
    assert [ -n "$2" ]
    printf '            - %s:%s\n' "${1:-$(get_default_volume_name $2)}" "$2"
}

print_volumes() {
    if [ "$named_volumes" = false ]; then
	return 0
    fi

    if [ "$(get_volume_count)" -eq 0 ]; then
	return 0
    fi

    printf '%s\n' ''
    printf '%s:\n' "volumes"

    get_volumes | while read device mount name; do
	check_device "$device"
	print_volume "$device" "$mount" "$name"
    done
}

validate_platform() {
    awk_version_string=$(get_awk_version_string)

    if [ -n "$awk_version_string" ]; then
	awk_version=$(get_awk_version_number "$awk_version_string")

	if [ -n "$awk_version" ]; then
	    delta=$(compare_versions "${awk_version:-0.0.0}" "$AWK_VERSION" 3)

	    if [ -n "$delta" -a "$delta" -ge 0 ]; then
		return 0
	    fi
	fi
    fi

    abort '%s: GNU AWK version %s or greater is required\n' \
	  "$script" \
	  $AWK_VERSION
}

usage() {
    cat <<EOF >&2
Usage: $script [-n]
       $script [-u]
       $script -h
EOF
}

usage_error() {
    if [ $# -gt 0 ]; then
	printf "$@" >&2
    fi

    printf '%s\n' '' >&2
    usage
    exit 2
}

script="$0"
parse_arguments "$@"
generate_docker_compose
