#!/bin/sh -eu

# generate-docker-compose: print configuration file docker-compose.yaml
# Copyright (C) 2021  "Michael G. Morey" <mgmorey@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

AWK_VERSION=4.0.0
FILE_VERSION=3.3
NAMED_VOLUMES=true

VOLUME_UID=500

ENV_FILE=docker-environment.txt
PORT_FILE=docker-ports.txt
SERVICE_FILE=docker-service.txt
VOLUME_FILE=docker-volumes.txt

ENV_NAME_RE='[A-Za-z][0-9A-Z_a-z]+'
ENV_RE="${ENV_NAME_RE}=.+"

IPV4_RE='[0-9]{1,3}(\.[0-9]{1,3}){3}'
PORT_NUMBER_RE='[0-9]{1,5}'
PORT_RANGE_RE="${PORT_NUMBER_RE}(-${PORT_NUMBER_RE})?"
PORT_RE="(${IPV4_RE}:)?(${PORT_RANGE_RE}:)?${PORT_RANGE_RE}([/](tcp|udp))?"

SERVICE_NAME_RE='[a-z][0-9_a-z]*'
SERVICE_RE="${SERVICE_NAME_RE}=.+"

VOLUME_NAME_RE='[a-z][0-9_a-z-]*'
VOLUME_PATH_RE="([/]${VOLUME_NAME_RE})+"
VOLUME_RE="\\.{,2}(${VOLUME_PATH_RE})?:${VOLUME_PATH_RE}(:${VOLUME_NAME_RE})?"

abort() {
    printf "$@" >&2
    exit 1
}

assert() {
    "$@" || abort "%s: Assertion failed: %s\n" "$script" "$*"
}

check_device() {
    assert [ $# -eq 1 ]
    assert [ -n "$1" ]

    if [ ! -d "$1" ]; then
	printf '%s: WARNING: %s: No such directory\n' "$script" "$1" >&2
    fi
}

compare_versions() (
    assert [ $# -eq 3 ]
    assert [ -n "$3" ]

    if [ -z "$1" -a -z "$2" -o "$3" -le 0 ]; then
	printf '%s\n' 0
    else
	m=$(printf '%s\n' "${1:-0}" | cut -d. -f 1)
	n=$(printf '%s\n' "${2:-0}" | cut -d. -f 1)
	delta=$((m - n))

	if [ "$delta" -ne 0 ]; then
	    printf '%s\n' $delta
	else
	    printf '%s\n' "$(compare_versions ${1#*.} ${2#*.} $(($3 - 1)))"
	fi
    fi
)

find_file() {
    assert [ $# -eq 1 ]
    assert [ -n "$1" ]

    for dir in . .. "$HOME"; do
	file="$dir/$1"

	if [ -f "$file" ]; then
	    printf '%s\n' "$file"
	    return 0
	fi
    done

    printf '%s\n' "$1"
}

generate_docker_compose() {
    validate_platform
    env_file=$(find_file $ENV_FILE)
    port_file=$(find_file $PORT_FILE)
    service_file=$(find_file $SERVICE_FILE)
    volume_file=$(find_file $VOLUME_FILE)

    if [ -z "$volume_home" ]; then
	volume_home="$(get_default_volume_home)"
    fi

    print_file_version
    print_services
    print_volumes
}

get_awk_version_number() {
    expr "${1-}" : 'GNU Awk \([1-9][0-9]*\(\.[0-9][0-9]*\)*\)'
}

get_awk_version_string() {
    awk --version 2>/dev/null | head -n 1
}

get_default_service_name() {
    image=$(get_service_param_value image | sed 's/:.*$//')

    if [ -n "$image" ]; then
	printf '%s\n' "$(basename $image)"
    else
	printf '%s\n' app
    fi
}

get_default_volume_home() {
    volume_user=$(get_volume_user $VOLUME_UID)
    volume_gid=$(get_volume_gid $volume_user)

    if [ -z "$volume_gid" ]; then
	volume_gid=$VOLUME_GID
    fi

    volume_group=$(get_volume_group $volume_gid)
    get_volume_home $VOLUME_UID
}

get_default_volume_name() {
    assert [ $# -eq 1 ]
    assert [ -n "$1" ]
    printf '%s\n' "$1" | awk -F/ '
NF >= 3 {printf("%s-%s\n", $(NF - 1), $NF)}
NF <= 2 {printf("%s\n", $NF)}
'
}

get_environment_var_count() {
    get_environment_vars | wc -l
}

get_environment_vars() {
    if [ -f $env_file ]; then
	awk -F= '/^'"$ENV_RE"'$/ {print $1, $2}' $env_file
    fi
}

get_port_count() {
    get_ports | wc -l
}

get_ports() {
    if [ -f $port_file ]; then
	awk '/^'"$PORT_RE"'$/ {print $0}' $port_file
    fi
}

get_service_param_value() {
    assert [ $# -eq 1 ]
    assert [ -n "$1" ]
    awk -F= '$1 == "'"$1"'" {print $2}' $service_file
}

get_service_params() {
    awk -F= '/^'"$SERVICE_RE"'$/ {print $1, $2}' $service_file
}

get_volume_count() {
    get_volumes | wc -l
}

get_volume_gid() {
    if [ -n "${1-}" ]; then
	getent passwd $1 | cut -d: -f 4
    fi
}

get_volume_group() {
    if [ -n "${1-}" ]; then
	getent group $1 | cut -d: -f 1
    fi
}

get_volume_home() {
    if [ -n "${1-}" ]; then
	getent passwd $1 | cut -d: -f 6
    fi
}

get_volume_user() {
    if [ -n "${1-}" ]; then
	getent passwd $1 | cut -d: -f 1
    fi
}

get_volumes() {
    if [ -n "$volume_home" ]; then
	sed -e 's|^\.\./volumes/|'"$volume_home"'/|' \
	    -e 's|^~/|'"$volume_home"'/|' $volume_file
    else
	cat $volume_file
    fi | awk -F: '/^'"$VOLUME_RE"'$/ {print $1, $2, $3}'
}

parse_arguments() {
    named_volumes=$NAMED_VOLUMES
    volume_home=

    while getopts d:nuh opt; do
	case $opt in
	    (d)
		volume_home=$OPTARG
		;;
	    (n)
		named_volumes=true
		;;
	    (u)
		named_volumes=false
		;;
	    (h)
		usage
		exit 0
		;;
	    (\?)
		exit 2
		;;
	esac
    done

    shift $(($OPTIND - 1))

    if [ $# -gt 0 ]; then
	usage_error "%s: Too many arguments\n" "$script"
    fi
}

print_file_version() {
    printf '%s: "%s"\n' "version" "$FILE_VERSION"
}

print_service_environment() {
    if [ "$(get_environment_var_count)" -eq 0 ]; then
	return 0
    fi

    printf '        %s:\n' "environment"

    get_environment_vars | sort | while read var value; do
	printf '            - %s=%s\n' "$var" "$value"
    done
}

print_service_ports() {
    if [ "$(get_port_count)" -eq 0 ]; then
	return 0
    fi

    printf '        %s:\n' "ports"

    get_ports | while read port; do
	if expr "$port" : '^[0-9-]*$' >/dev/null; then
	    printf '            - %s:%s\n' "$port" "$port"
	else
	    printf '            - %s\n' "$port"
	fi
    done
}

print_service_volumes() {
    if [ "$(get_volume_count)" -eq 0 ]; then
	return 0
    fi

    printf '        %s:\n' "volumes"

    get_volumes | while read device mount name; do
	check_device "$device"

	if [ "$named_volumes" = true ]; then
	    print_volume_name_and_mount "$name" "$mount"
	else
	    print_volume_device_and_mount "$device" "$mount"
	fi
    done
}

print_services() {
    printf '%s\n' ''
    printf '%s:\n' "services"
    printf '%s\n' ''
    service_name=$(get_service_param_value service_name)
    printf '    %s:\n' "${service_name:-$(get_default_service_name)}"

    get_service_params | sort | while read param value; do
	if [ "$param" != service_name ]; then
	    printf '        %s: %s\n' "$param" "$value"
	fi
    done

    print_service_environment
    print_service_ports
    print_service_volumes
}

print_volume() {
    printf '%s\n' ''
    printf '    %s:\n' "${3:-$(get_default_volume_name $2)}"
    printf '        %s: %s\n' "driver" "local"
    printf '        %s:\n' "driver_opts"
    printf '            %s: %s\n' "o" "bind"
    printf '            %s: %s\n' "type" "none"
    printf '            %s: %s\n' "device" "$1"
}

print_volume_device_and_mount() {
    assert [ $# -eq 2 ]
    assert [ -n "$1" ]
    assert [ -n "$2" ]
    printf '            - %s:%s\n' "$1" "$2"
}

print_volume_name_and_mount() {
    assert [ $# -eq 2 ]
    assert [ -n "$2" ]
    printf '            - %s:%s\n' "${1:-$(get_default_volume_name $2)}" "$2"
}

print_volumes() {
    if [ "$named_volumes" = false ]; then
	return 0
    fi

    if [ "$(get_volume_count)" -eq 0 ]; then
	return 0
    fi

    printf '%s\n' ''
    printf '%s:\n' "volumes"

    get_volumes | while read device mount name; do
	check_device "$device"
	print_volume "$device" "$mount" "$name"
    done
}

validate_platform() {
    awk_version_string=$(get_awk_version_string)

    if [ -n "$awk_version_string" ]; then
	awk_version=$(get_awk_version_number "$awk_version_string")

	if [ -n "$awk_version" ]; then
	    delta=$(compare_versions "${awk_version:-0.0.0}" "$AWK_VERSION" 3)

	    if [ -n "$delta" -a "$delta" -ge 0 ]; then
		return 0
	    fi
	fi
    fi

    abort '%s: GNU Awk version %s or greater is required\n' \
	  "$script" \
	  $AWK_VERSION
}

usage() {
    cat <<EOF >&2
Usage: $script [-d VOLUME-HOME]
       $script -n [-d VOLUME-HOME]
       $script -u [-d VOLUME-HOME]
       $script -h

Generate Docker Compose YAML.

  -d VOLUME-HOME  substitute VOLUME-HOME for tilde ("~") in volume devices
  -h              print this help text (all other options are ignored)
  -n              define named volumes
  -u              define unnamed volumes
EOF
}

usage_error() {
    if [ $# -gt 0 ]; then
	printf "$@" >&2
    fi

    printf '%s\n' '' >&2
    usage
    exit 2
}

script=$(basename "$0")
parse_arguments "$@"
generate_docker_compose
